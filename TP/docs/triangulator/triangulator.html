<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>triangulator.triangulator API documentation</title>
<meta name="description" content="Module de triangulation.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>triangulator.triangulator</code></h1>
</header>
<section id="section-intro">
<p>Module de triangulation.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="triangulator.triangulator.Triangulator"><code class="flex name class">
<span>class <span class="ident">Triangulator</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Triangulator:
    &#34;&#34;&#34;Classe responsable de la triangulation d&#39;un ensemble de points.&#34;&#34;&#34;

    def encode_pointset(self, points) -&gt; bytes:
        &#34;&#34;&#34;Encode un PointSet au format binaire.&#34;&#34;&#34;
        N = len(points)

        # I signifie unsigned long (4 octets)
        # f signifie float (4 octets)
        # &lt; signifie little-endian (le moins significatif est stocké en premier)
        # &gt; signifie big-endian (le plus significatif est stocké en premier)
        
        # Le but ici est d&#39;écrire le header 
        # ( qui est censer représenter le nombre de points)
        # struct.pack(&#39;&lt;I&#39;, N) va créer 4 octets représentant cet espace et y ajouter N
        binary_pointSet = struct.pack(&#39;&lt;I&#39;, N)
        
        # Ici on boucle pour écrire les points dans binary_pointSet
        for point in points:
            # On s&#39;assure que ce sont des floats (x, y)
            x, y = point
            # struct.pack(&#39;&lt;ff&#39;, float(x), float(y)) 
            # va créer 8 octets représentant cet espace et y ajouter x et y
            binary_pointSet += struct.pack(&#39;&lt;ff&#39;, float(x), float(y))
            
        return binary_pointSet

    def fetch_pointset(self, pointset_id: str) -&gt; bytes:
        &#34;&#34;&#34;Récupère le PointSet binaire depuis le PointSetManager.&#34;&#34;&#34;
        # 1. On construit l&#39;URL (ex: /pointset/123-abc...)
        url = f&#34;http://localhost:8080/pointset/{pointset_id}&#34;
        
        try:
            # 2. On ouvre la connexion
            with urllib.request.urlopen(url) as response:
                # 3. Si ça marche (code 200), on lit tout le contenu binaire
                return response.read() # Ceci retourne des &#39;bytes&#39;

        except urllib.error.HTTPError as e:
            # Le serveur a répondu, mais avec une erreur (404, 500...)
            if e.code == 404:
                raise FileNotFoundError(f&#34;PointSet {pointset_id} introuvable&#34;) from e
            elif e.code == 503:
                raise ConnectionError(&#34;PointSetManager en maintenance&#34;) from e
            else:
                raise ValueError(f&#34;Erreur HTTP {e.code}: {e.reason}&#34;) from e
                
        except urllib.error.URLError as e:
            # Le serveur n&#39;est même pas accessible (éteint, pas de wifi...)
            # Ton app.py attrapera cette exception générique et renverra une 503.
            raise ConnectionError(f&#34;Impossible de joindre le PSM: {e.reason}&#34;) from e

    def decode_pointset(self, binary: bytes):
        &#34;&#34;&#34;Décode le PointSet au format binaire → liste de points.&#34;&#34;&#34;
        # Vérification minimale de la taille (4 bytes pour N)
        if len(binary) &lt; 4:
            raise ValueError(&#34;Données binaires invalides ou incomplètes&#34;)

        # Ici on va lire N
        try:
            N = struct.unpack(&#39;&lt;I&#39;, binary[:4])[0]
        except struct.error as e:
            raise ValueError(&#34;Impossible de lire le nombre de points&#34;) from e

        # Vérification de la cohérence de la taille totale
        # 4 bytes (header) + N * 8 bytes (corps : 2 floats de 4 bytes par point)
        expected_size = 4 + (N * 8)
        if len(binary) &lt; expected_size:
            raise ValueError(
                f&#34;Taille incorrecte : attendu {expected_size}, reçu {len(binary)}&#34;
            )

        points = []
        position = 4
        
        # Ici on va lire les points
        for _ in range(N):
            # on va prendre 8 octets
            chunk = binary[position : position + 8]
            x, y = struct.unpack(&#39;&lt;ff&#39;, chunk)
            points.append((x, y))
            position += 8

        return points

    def is_in_circumcircle(self, point, triangle, points):
        &#34;&#34;&#34;Vérifie si un point est dans le cercle circonscrit d&#39;un triangle.&#34;&#34;&#34;
        # 1. On récupère les 3 sommets du triangle
        a = points[triangle[0]]
        b = points[triangle[1]]
        c = points[triangle[2]]

        # 2. On simplifie en ramenant &#39;p&#39; à l&#39;origine (0,0)
        ax, ay = a[0] - point[0], a[1] - point[1]
        bx, by = b[0] - point[0], b[1] - point[1]
        cx, cy = c[0] - point[0], c[1] - point[1]

        # 3. On calcule le déterminant
        det = ( (ax*ax + ay*ay) * (bx*cy - cx*by) -
                (bx*bx + by*by) * (ax*cy - cx*ay) +
                (cx*cx + cy*cy) * (ax*by - bx*ay) )
                
        # 4. On retourne True si le déterminant est positif
        return det &gt; 0

    def triangulate(self, points):
        &#34;&#34;&#34;Triangulation d&#39;un nuage de points en triangles (Bowyer-Watson).&#34;&#34;&#34;
        # ETAPE 1 : VERIFICATIONS DE BASE
        
        # Si la liste est vide, on ne peut rien faire
        if not points:
            return []
        
        # On récupère le nombre de points
        n_points = len(points)
        
        # Il faut au moins 3 points pour faire un triangle
        if n_points &lt; 3:
            raise ValueError(&#34;Impossible de trianguler moins de 3 points&#34;)

        # ETAPE 2 : ANALYSE DES DONNEES (BOUNDING BOX)

        # On extrait toutes les coordonnées X et Y pour trouver les limites
        x = [p[0] for p in points]
        y = [p[1] for p in points]
        min_x, max_x = min(x), max(x)
        min_y, max_y = min(y), max(y)

        # Vérification de la colinéarité
        if math.isclose(min_x, max_x) or math.isclose(min_y, max_y):
             raise ValueError(&#34;Points colinéaires ou confondus&#34;)

        # ETAPE 3 : CREATION DU SUPER-TRIANGLE

        # On calcule les dimensions de la zone
        dx = max_x - min_x
        dy = max_y - min_y
        # On prend la plus grande dimension pour faire un triangle assez grand
        delta_max = max(dx, dy) if max(dx, dy) &gt; 0 else 1.0
        
        # On calcule le centre du nuage de points
        mid_x = (min_x + max_x) / 2
        mid_y = (min_y + max_y) / 2

        # On crée 3 points virtuels géants qui englobent tout le nuage
        # La multiplication par 20 permet d&#39;être sur qu&#39;il englobe tout le nuage
        p1 = (mid_x - 20 * delta_max, mid_y - delta_max)
        p2 = (mid_x, mid_y + 20 * delta_max)
        p3 = (mid_x + 20 * delta_max, mid_y - delta_max)

        # On crée une liste de travail qui contient
        # les vrais points + les 3 points virtuels
        working_points = points + [p1, p2, p3]
        
        # Les indices des points du Super-Triangle sont à la fin de la liste
        st1 = n_points
        st2 = n_points + 1
        st3 = n_points + 2

        # On initialise la liste des triangles avec ce Super-Triangle unique
        triangles = [(st1, st3, st2)]

        # ETAPE 4 : LA BOUCLE PRINCIPALE (INCREMENTALE)

        # On insère chaque point un par un dans la triangulation existante
        for i, point in enumerate(points):
            
            # Liste des triangles qui ne respectent
            # plus la condition de Delaunay (à supprimer)
            bad_triangles = []
            
            # Liste temporaire pour garder les bons triangles
            temp_triangles = []

            # Identification des mauvais triangles
            for tri in triangles:
                # Si le nouveau point est dans le cercle circonscrit de ce triangle
                if self.is_in_circumcircle(point, tri, working_points):
                    # alors ce triangle est a enlever
                    bad_triangles.append(tri)
                else:
                    # sinon, on le garde pour la prochaine étape
                    temp_triangles.append(tri)
            
            # On met à jour la liste principale en ne gardant que les bons
            triangles = temp_triangles

            # Calcul du Polygone de Bowyer-Watson ( un gros trou )
            # Le but est de trouver le contour extérieur du trou
            # formé par les bad_triangles.
            # On doit trouver une arête interne est partagée par 2 bad_triangles.
            # Une arête frontière n&#39;appartient qu&#39;à 1 seul bad_triangle.
            boundary_edges = set()
            
            for tri in bad_triangles:
                # On liste les 3 arêtes du triangle : (A,B), (B,C), (C,A)
                edges = [(tri[0], tri[1]), (tri[1], tri[2]), (tri[2], tri[0])]
                
                for edge in edges:
                    # On calcule l&#39;arête inverse (B,A)
                    reversed_edge = (edge[1], edge[0])
                    
                    # Si l&#39;inverse est déjà dans le set, c&#39;est que l&#39;arête est partagée
                    if reversed_edge in boundary_edges:
                        # Donc c&#39;est une arête interne, on la supprime
                        # (elles s&#39;annulent)
                        boundary_edges.remove(reversed_edge)
                    else:
                        # Sinon, c&#39;est potentiellement une frontière, on l&#39;ajoute
                        boundary_edges.add(edge)

            # Re-bouchage du trou
            # Pour chaque arête du contour,
            # on crée un nouveau triangle avec le point &#39;i&#39;
            for edge in boundary_edges:
                # On forme le triangle (Point1, Point2, NouveauPoint)
                new_tri = (edge[0], edge[1], i)
                # On l&#39;ajoute à la liste principale
                triangles.append(new_tri)

        # Nettoyage final
        
        final_triangles = []
        
        # On parcourt tous les triangles créés
        for tri in triangles:
            # Si indice sommets &gt;= n_points, c&#39;est un sommet du Super-Triangle
            if tri[0] &gt;= n_points or tri[1] &gt;= n_points or tri[2] &gt;= n_points:
                # On ne garde pas ce triangle car il est connecté à rien
                continue
            
            # Sinon, c&#39;est un triangle valide
            final_triangles.append(tri)

        # sécurité finale
        
        # cas d&#39;une ligne droite
        if not final_triangles and n_points &gt;= 3:
             raise ValueError(&#34;Erreur triangulation (potentiellement colinéaires)&#34;)

        # On retourne la liste finale
        return final_triangles

    def encode_triangles(self, points, triangles) -&gt; bytes:
        &#34;&#34;&#34;Encode la réponse Triangles au format binaire.&#34;&#34;&#34;
        # On réutilise l&#39;encodeur de points
        pointSet = self.encode_pointset(points)

        # On encode la partie triangles
        T = len(triangles)
        
        nombreDeTriangle = struct.pack(&#39;&lt;I&#39;, T)
        
        trianglesEncodees = bytearray()
        for t in triangles:
            # Chaque triangle est un tuple (i1, i2, i3)
            # On encode 3 unsigned int (&#39;&lt;III&#39;) soit 12 octets
            trianglesEncodees += struct.pack(&#39;&lt;III&#39;, t[0], t[1], t[2])

        # On colle tout ensemble
        return pointSet + nombreDeTriangle + trianglesEncodees

    def decode_triangles(self, binary: bytes):
        &#34;&#34;&#34;Décode réponse Triangles depuis format binaire.&#34;&#34;&#34;
        # On lit les points
        points = self.decode_pointset(binary)
        
        # On calcule où la partie Triangles commence
        # Taille partie 1 = 4 bytes (N) + N * 8 bytes
        N = len(points)
        position = 4 + (N * 8)
        
        # Vérification qu&#39;on a bien la suite (au moins le nombre T)
        if len(binary) &lt; position + 4:
             raise ValueError(&#34;Données binaires incomplètes pour les triangles&#34;)
             
        # Lecture du nombre de triangles T
        T = struct.unpack(&#39;&lt;I&#39;, binary[position : position + 4])[0]
        position += 4
        
        triangles = []
        for _ in range(T):
            if len(binary) &lt; position + 12:
                raise ValueError(&#34;Données corrompues dans les triangles&#34;)
                
            # Lecture du triplet d&#39;indices (3 * 4 bytes)
            chunk = binary[position : position + 12]
            i1, i2, i3 = struct.unpack(&#39;&lt;III&#39;, chunk)
            triangles.append((i1, i2, i3))
            position += 12
            
        return triangles
    
    def triangulate_from_id(self, pointset_id: str):
        &#34;&#34;&#34;Récupère un PointSet → le triangule → renvoie la structure resultante.&#34;&#34;&#34;
        binary = self.fetch_pointset(pointset_id)
        points = self.decode_pointset(binary)
        triangles = self.triangulate(points)
        return self.encode_triangles(points, triangles)</code></pre>
</details>
<div class="desc"><p>Classe responsable de la triangulation d'un ensemble de points.</p></div>
<h3>Methods</h3>
<dl>
<dt id="triangulator.triangulator.Triangulator.decode_pointset"><code class="name flex">
<span>def <span class="ident">decode_pointset</span></span>(<span>self, binary: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_pointset(self, binary: bytes):
    &#34;&#34;&#34;Décode le PointSet au format binaire → liste de points.&#34;&#34;&#34;
    # Vérification minimale de la taille (4 bytes pour N)
    if len(binary) &lt; 4:
        raise ValueError(&#34;Données binaires invalides ou incomplètes&#34;)

    # Ici on va lire N
    try:
        N = struct.unpack(&#39;&lt;I&#39;, binary[:4])[0]
    except struct.error as e:
        raise ValueError(&#34;Impossible de lire le nombre de points&#34;) from e

    # Vérification de la cohérence de la taille totale
    # 4 bytes (header) + N * 8 bytes (corps : 2 floats de 4 bytes par point)
    expected_size = 4 + (N * 8)
    if len(binary) &lt; expected_size:
        raise ValueError(
            f&#34;Taille incorrecte : attendu {expected_size}, reçu {len(binary)}&#34;
        )

    points = []
    position = 4
    
    # Ici on va lire les points
    for _ in range(N):
        # on va prendre 8 octets
        chunk = binary[position : position + 8]
        x, y = struct.unpack(&#39;&lt;ff&#39;, chunk)
        points.append((x, y))
        position += 8

    return points</code></pre>
</details>
<div class="desc"><p>Décode le PointSet au format binaire → liste de points.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.decode_triangles"><code class="name flex">
<span>def <span class="ident">decode_triangles</span></span>(<span>self, binary: bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_triangles(self, binary: bytes):
    &#34;&#34;&#34;Décode réponse Triangles depuis format binaire.&#34;&#34;&#34;
    # On lit les points
    points = self.decode_pointset(binary)
    
    # On calcule où la partie Triangles commence
    # Taille partie 1 = 4 bytes (N) + N * 8 bytes
    N = len(points)
    position = 4 + (N * 8)
    
    # Vérification qu&#39;on a bien la suite (au moins le nombre T)
    if len(binary) &lt; position + 4:
         raise ValueError(&#34;Données binaires incomplètes pour les triangles&#34;)
         
    # Lecture du nombre de triangles T
    T = struct.unpack(&#39;&lt;I&#39;, binary[position : position + 4])[0]
    position += 4
    
    triangles = []
    for _ in range(T):
        if len(binary) &lt; position + 12:
            raise ValueError(&#34;Données corrompues dans les triangles&#34;)
            
        # Lecture du triplet d&#39;indices (3 * 4 bytes)
        chunk = binary[position : position + 12]
        i1, i2, i3 = struct.unpack(&#39;&lt;III&#39;, chunk)
        triangles.append((i1, i2, i3))
        position += 12
        
    return triangles</code></pre>
</details>
<div class="desc"><p>Décode réponse Triangles depuis format binaire.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.encode_pointset"><code class="name flex">
<span>def <span class="ident">encode_pointset</span></span>(<span>self, points) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_pointset(self, points) -&gt; bytes:
    &#34;&#34;&#34;Encode un PointSet au format binaire.&#34;&#34;&#34;
    N = len(points)

    # I signifie unsigned long (4 octets)
    # f signifie float (4 octets)
    # &lt; signifie little-endian (le moins significatif est stocké en premier)
    # &gt; signifie big-endian (le plus significatif est stocké en premier)
    
    # Le but ici est d&#39;écrire le header 
    # ( qui est censer représenter le nombre de points)
    # struct.pack(&#39;&lt;I&#39;, N) va créer 4 octets représentant cet espace et y ajouter N
    binary_pointSet = struct.pack(&#39;&lt;I&#39;, N)
    
    # Ici on boucle pour écrire les points dans binary_pointSet
    for point in points:
        # On s&#39;assure que ce sont des floats (x, y)
        x, y = point
        # struct.pack(&#39;&lt;ff&#39;, float(x), float(y)) 
        # va créer 8 octets représentant cet espace et y ajouter x et y
        binary_pointSet += struct.pack(&#39;&lt;ff&#39;, float(x), float(y))
        
    return binary_pointSet</code></pre>
</details>
<div class="desc"><p>Encode un PointSet au format binaire.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.encode_triangles"><code class="name flex">
<span>def <span class="ident">encode_triangles</span></span>(<span>self, points, triangles) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_triangles(self, points, triangles) -&gt; bytes:
    &#34;&#34;&#34;Encode la réponse Triangles au format binaire.&#34;&#34;&#34;
    # On réutilise l&#39;encodeur de points
    pointSet = self.encode_pointset(points)

    # On encode la partie triangles
    T = len(triangles)
    
    nombreDeTriangle = struct.pack(&#39;&lt;I&#39;, T)
    
    trianglesEncodees = bytearray()
    for t in triangles:
        # Chaque triangle est un tuple (i1, i2, i3)
        # On encode 3 unsigned int (&#39;&lt;III&#39;) soit 12 octets
        trianglesEncodees += struct.pack(&#39;&lt;III&#39;, t[0], t[1], t[2])

    # On colle tout ensemble
    return pointSet + nombreDeTriangle + trianglesEncodees</code></pre>
</details>
<div class="desc"><p>Encode la réponse Triangles au format binaire.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.fetch_pointset"><code class="name flex">
<span>def <span class="ident">fetch_pointset</span></span>(<span>self, pointset_id: str) ‑> bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_pointset(self, pointset_id: str) -&gt; bytes:
    &#34;&#34;&#34;Récupère le PointSet binaire depuis le PointSetManager.&#34;&#34;&#34;
    # 1. On construit l&#39;URL (ex: /pointset/123-abc...)
    url = f&#34;http://localhost:8080/pointset/{pointset_id}&#34;
    
    try:
        # 2. On ouvre la connexion
        with urllib.request.urlopen(url) as response:
            # 3. Si ça marche (code 200), on lit tout le contenu binaire
            return response.read() # Ceci retourne des &#39;bytes&#39;

    except urllib.error.HTTPError as e:
        # Le serveur a répondu, mais avec une erreur (404, 500...)
        if e.code == 404:
            raise FileNotFoundError(f&#34;PointSet {pointset_id} introuvable&#34;) from e
        elif e.code == 503:
            raise ConnectionError(&#34;PointSetManager en maintenance&#34;) from e
        else:
            raise ValueError(f&#34;Erreur HTTP {e.code}: {e.reason}&#34;) from e
            
    except urllib.error.URLError as e:
        # Le serveur n&#39;est même pas accessible (éteint, pas de wifi...)
        # Ton app.py attrapera cette exception générique et renverra une 503.
        raise ConnectionError(f&#34;Impossible de joindre le PSM: {e.reason}&#34;) from e</code></pre>
</details>
<div class="desc"><p>Récupère le PointSet binaire depuis le PointSetManager.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.is_in_circumcircle"><code class="name flex">
<span>def <span class="ident">is_in_circumcircle</span></span>(<span>self, point, triangle, points)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_in_circumcircle(self, point, triangle, points):
    &#34;&#34;&#34;Vérifie si un point est dans le cercle circonscrit d&#39;un triangle.&#34;&#34;&#34;
    # 1. On récupère les 3 sommets du triangle
    a = points[triangle[0]]
    b = points[triangle[1]]
    c = points[triangle[2]]

    # 2. On simplifie en ramenant &#39;p&#39; à l&#39;origine (0,0)
    ax, ay = a[0] - point[0], a[1] - point[1]
    bx, by = b[0] - point[0], b[1] - point[1]
    cx, cy = c[0] - point[0], c[1] - point[1]

    # 3. On calcule le déterminant
    det = ( (ax*ax + ay*ay) * (bx*cy - cx*by) -
            (bx*bx + by*by) * (ax*cy - cx*ay) +
            (cx*cx + cy*cy) * (ax*by - bx*ay) )
            
    # 4. On retourne True si le déterminant est positif
    return det &gt; 0</code></pre>
</details>
<div class="desc"><p>Vérifie si un point est dans le cercle circonscrit d'un triangle.</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self, points):
    &#34;&#34;&#34;Triangulation d&#39;un nuage de points en triangles (Bowyer-Watson).&#34;&#34;&#34;
    # ETAPE 1 : VERIFICATIONS DE BASE
    
    # Si la liste est vide, on ne peut rien faire
    if not points:
        return []
    
    # On récupère le nombre de points
    n_points = len(points)
    
    # Il faut au moins 3 points pour faire un triangle
    if n_points &lt; 3:
        raise ValueError(&#34;Impossible de trianguler moins de 3 points&#34;)

    # ETAPE 2 : ANALYSE DES DONNEES (BOUNDING BOX)

    # On extrait toutes les coordonnées X et Y pour trouver les limites
    x = [p[0] for p in points]
    y = [p[1] for p in points]
    min_x, max_x = min(x), max(x)
    min_y, max_y = min(y), max(y)

    # Vérification de la colinéarité
    if math.isclose(min_x, max_x) or math.isclose(min_y, max_y):
         raise ValueError(&#34;Points colinéaires ou confondus&#34;)

    # ETAPE 3 : CREATION DU SUPER-TRIANGLE

    # On calcule les dimensions de la zone
    dx = max_x - min_x
    dy = max_y - min_y
    # On prend la plus grande dimension pour faire un triangle assez grand
    delta_max = max(dx, dy) if max(dx, dy) &gt; 0 else 1.0
    
    # On calcule le centre du nuage de points
    mid_x = (min_x + max_x) / 2
    mid_y = (min_y + max_y) / 2

    # On crée 3 points virtuels géants qui englobent tout le nuage
    # La multiplication par 20 permet d&#39;être sur qu&#39;il englobe tout le nuage
    p1 = (mid_x - 20 * delta_max, mid_y - delta_max)
    p2 = (mid_x, mid_y + 20 * delta_max)
    p3 = (mid_x + 20 * delta_max, mid_y - delta_max)

    # On crée une liste de travail qui contient
    # les vrais points + les 3 points virtuels
    working_points = points + [p1, p2, p3]
    
    # Les indices des points du Super-Triangle sont à la fin de la liste
    st1 = n_points
    st2 = n_points + 1
    st3 = n_points + 2

    # On initialise la liste des triangles avec ce Super-Triangle unique
    triangles = [(st1, st3, st2)]

    # ETAPE 4 : LA BOUCLE PRINCIPALE (INCREMENTALE)

    # On insère chaque point un par un dans la triangulation existante
    for i, point in enumerate(points):
        
        # Liste des triangles qui ne respectent
        # plus la condition de Delaunay (à supprimer)
        bad_triangles = []
        
        # Liste temporaire pour garder les bons triangles
        temp_triangles = []

        # Identification des mauvais triangles
        for tri in triangles:
            # Si le nouveau point est dans le cercle circonscrit de ce triangle
            if self.is_in_circumcircle(point, tri, working_points):
                # alors ce triangle est a enlever
                bad_triangles.append(tri)
            else:
                # sinon, on le garde pour la prochaine étape
                temp_triangles.append(tri)
        
        # On met à jour la liste principale en ne gardant que les bons
        triangles = temp_triangles

        # Calcul du Polygone de Bowyer-Watson ( un gros trou )
        # Le but est de trouver le contour extérieur du trou
        # formé par les bad_triangles.
        # On doit trouver une arête interne est partagée par 2 bad_triangles.
        # Une arête frontière n&#39;appartient qu&#39;à 1 seul bad_triangle.
        boundary_edges = set()
        
        for tri in bad_triangles:
            # On liste les 3 arêtes du triangle : (A,B), (B,C), (C,A)
            edges = [(tri[0], tri[1]), (tri[1], tri[2]), (tri[2], tri[0])]
            
            for edge in edges:
                # On calcule l&#39;arête inverse (B,A)
                reversed_edge = (edge[1], edge[0])
                
                # Si l&#39;inverse est déjà dans le set, c&#39;est que l&#39;arête est partagée
                if reversed_edge in boundary_edges:
                    # Donc c&#39;est une arête interne, on la supprime
                    # (elles s&#39;annulent)
                    boundary_edges.remove(reversed_edge)
                else:
                    # Sinon, c&#39;est potentiellement une frontière, on l&#39;ajoute
                    boundary_edges.add(edge)

        # Re-bouchage du trou
        # Pour chaque arête du contour,
        # on crée un nouveau triangle avec le point &#39;i&#39;
        for edge in boundary_edges:
            # On forme le triangle (Point1, Point2, NouveauPoint)
            new_tri = (edge[0], edge[1], i)
            # On l&#39;ajoute à la liste principale
            triangles.append(new_tri)

    # Nettoyage final
    
    final_triangles = []
    
    # On parcourt tous les triangles créés
    for tri in triangles:
        # Si indice sommets &gt;= n_points, c&#39;est un sommet du Super-Triangle
        if tri[0] &gt;= n_points or tri[1] &gt;= n_points or tri[2] &gt;= n_points:
            # On ne garde pas ce triangle car il est connecté à rien
            continue
        
        # Sinon, c&#39;est un triangle valide
        final_triangles.append(tri)

    # sécurité finale
    
    # cas d&#39;une ligne droite
    if not final_triangles and n_points &gt;= 3:
         raise ValueError(&#34;Erreur triangulation (potentiellement colinéaires)&#34;)

    # On retourne la liste finale
    return final_triangles</code></pre>
</details>
<div class="desc"><p>Triangulation d'un nuage de points en triangles (Bowyer-Watson).</p></div>
</dd>
<dt id="triangulator.triangulator.Triangulator.triangulate_from_id"><code class="name flex">
<span>def <span class="ident">triangulate_from_id</span></span>(<span>self, pointset_id: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate_from_id(self, pointset_id: str):
    &#34;&#34;&#34;Récupère un PointSet → le triangule → renvoie la structure resultante.&#34;&#34;&#34;
    binary = self.fetch_pointset(pointset_id)
    points = self.decode_pointset(binary)
    triangles = self.triangulate(points)
    return self.encode_triangles(points, triangles)</code></pre>
</details>
<div class="desc"><p>Récupère un PointSet → le triangule → renvoie la structure resultante.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="triangulator" href="index.html">triangulator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="triangulator.triangulator.Triangulator" href="#triangulator.triangulator.Triangulator">Triangulator</a></code></h4>
<ul class="two-column">
<li><code><a title="triangulator.triangulator.Triangulator.decode_pointset" href="#triangulator.triangulator.Triangulator.decode_pointset">decode_pointset</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.decode_triangles" href="#triangulator.triangulator.Triangulator.decode_triangles">decode_triangles</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.encode_pointset" href="#triangulator.triangulator.Triangulator.encode_pointset">encode_pointset</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.encode_triangles" href="#triangulator.triangulator.Triangulator.encode_triangles">encode_triangles</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.fetch_pointset" href="#triangulator.triangulator.Triangulator.fetch_pointset">fetch_pointset</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.is_in_circumcircle" href="#triangulator.triangulator.Triangulator.is_in_circumcircle">is_in_circumcircle</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.triangulate" href="#triangulator.triangulator.Triangulator.triangulate">triangulate</a></code></li>
<li><code><a title="triangulator.triangulator.Triangulator.triangulate_from_id" href="#triangulator.triangulator.Triangulator.triangulate_from_id">triangulate_from_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
